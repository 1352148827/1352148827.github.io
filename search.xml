<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker私有仓库</title>
      <link href="/2020/03/08/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
      <url>/2020/03/08/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><pre><code>    docker私有仓库,作用是在一个局域网内,共享docker镜像</code></pre><h1 id="2-docker私有仓库的搭建"><a href="#2-docker私有仓库的搭建" class="headerlink" title="2 docker私有仓库的搭建"></a>2 docker私有仓库的搭建</h1><pre><code>docker私有仓库本身也是镜像</code></pre><h2 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h2><pre><code>docker pull registry</code></pre><h2 id="2-2-启动私有仓库"><a href="#2-2-启动私有仓库" class="headerlink" title="2.2 启动私有仓库"></a>2.2 启动私有仓库</h2><pre><code>docker run -di --name=registry -p 5000:5000  registry</code></pre><h2 id="2-3-查看是否创建成功"><a href="#2-3-查看是否创建成功" class="headerlink" title="2.3 查看是否创建成功"></a>2.3 查看是否创建成功</h2><pre><code>浏览器:  http://xxx.xxx.xxx.xxx:5000/v2/_catalog</code></pre><p>返回以下json表示创建成功</p><pre><code>[&quot;repostories&quot;:[]]</code></pre><h2 id="2-4-配置docker信任私有仓库"><a href="#2-4-配置docker信任私有仓库" class="headerlink" title="2.4 配置docker信任私有仓库"></a>2.4 配置docker信任私有仓库</h2><blockquote><p>编辑 docker配置文件 </p></blockquote><pre><code>vi /etc/docker/daemon.json</code></pre><blockquote><p>新增私有仓库地址 : 注:192.168.0.201为私有仓库的ip,根据需求修改</p></blockquote><pre><code>{&quot;registry-mirrors&quot;:[&quot;https://docker.mirrors.ustc.edu.cn&quot;],&quot;insecure-registries&quot;:[&quot;192.168.0.201:5000&quot;]}</code></pre><h2 id="2-5-重启docker"><a href="#2-5-重启docker" class="headerlink" title="2.5 重启docker"></a>2.5 重启docker</h2><pre><code>systemctl restart docker</code></pre><h1 id="3-上传镜像到私有仓库"><a href="#3-上传镜像到私有仓库" class="headerlink" title="3 上传镜像到私有仓库"></a>3 上传镜像到私有仓库</h1><h2 id="3-1-标记此镜像为私有仓库的镜像"><a href="#3-1-标记此镜像为私有仓库的镜像" class="headerlink" title="3.1  标记此镜像为私有仓库的镜像"></a>3.1  标记此镜像为私有仓库的镜像</h2><pre><code>docker tag 镜像名称 私库ip:5000/镜像名称示例:docker tag jdk1.8 192.168.0.201:5000/jdk1.8</code></pre><h2 id="3-2-启动私有仓库"><a href="#3-2-启动私有仓库" class="headerlink" title="3.2 启动私有仓库"></a>3.2 启动私有仓库</h2><pre><code>docker start registry</code></pre><h2 id="3-3-上传标记镜像"><a href="#3-3-上传标记镜像" class="headerlink" title="3.3 上传标记镜像"></a>3.3 上传标记镜像</h2><pre><code>docker push 192.168.0.201:5000/jdk1.8</code></pre><h1 id="4-mavne插件将工程发布到docker"><a href="#4-mavne插件将工程发布到docker" class="headerlink" title="4 mavne插件将工程发布到docker"></a>4 mavne插件将工程发布到docker</h1><h2 id="4-1-修改宿主机docker配置"><a href="#4-1-修改宿主机docker配置" class="headerlink" title="4.1  修改宿主机docker配置"></a>4.1  修改宿主机docker配置</h2><p>修改配置,使其可被远程访问 </p><pre><code>vi /lib/systemd/system/docker.service</code></pre><p>修改 ExecStart=/usr/bin/dockerd这一行 </p><pre><code>ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</code></pre><h2 id="4-2-刷新配置"><a href="#4-2-刷新配置" class="headerlink" title="4.2 刷新配置"></a>4.2 刷新配置</h2><pre><code>systemctl daemon-reloadsystemctl restart dockerdocker start registry</code></pre><h2 id="4-3-在maven工程配置插件"><a href="#4-3-在maven工程配置插件" class="headerlink" title="4.3 在maven工程配置插件"></a>4.3 在maven工程配置插件</h2><pre><code class="xml">&lt;build&gt;        &lt;!-- 设置工程名--&gt;        &lt;finalName&gt;app&lt;/finalName&gt;        &lt;plugins&gt;            &lt;!--springboot的maven插件--&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;            &lt;!-- docker 的 maven 插件，官网：https://github.com/spotify/docker-maven-plugin --&gt;            &lt;plugin&gt;                &lt;groupId&gt;com.spotify&lt;/groupId&gt;                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;0.4.13&lt;/version&gt;                &lt;configuration&gt;                    &lt;imageName&gt;192.168.25.129:5000/${project.artifactId}:${project.version}&lt;/imageName&gt;                    &lt;baseImage&gt;jdk1.8&lt;/baseImage&gt;                    &lt;entryPoint&gt;[&quot;java&quot;,&quot;-jar&quot;,&quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt;                    &lt;resources&gt;                        &lt;resource&gt;                            &lt;targetPath&gt;/&lt;/targetPath&gt;                            &lt;directory&gt;${project.build.directory}                            &lt;/directory&gt;                            &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                        &lt;/resource&gt;                    &lt;/resources&gt;                    &lt;dockerHost&gt;http://192.168.25.129:2375&lt;/dockerHost&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><h2 id="4-4-创建并上传镜像"><a href="#4-4-创建并上传镜像" class="headerlink" title="4.4 创建并上传镜像"></a>4.4 创建并上传镜像</h2><blockquote><p>进入工程目录,执行以下语句,该命令包含clean,打包,创建镜像,上传镜像</p></blockquote><pre><code>E:\IdeaProjects\tenpower-parent\tenpower-config&gt;mvn clean package docker:build -DpushImage</code></pre><h2 id="4-5-查看镜像是否上传成功"><a href="#4-5-查看镜像是否上传成功" class="headerlink" title="4.5 查看镜像是否上传成功"></a>4.5 查看镜像是否上传成功</h2><p>浏览器访问:</p><pre><code>http://192.168.0.201:5000/v2/_catalog</code></pre><p>是否出现</p><pre><code>{&quot;repositories&quot;:[&quot;tenpower-config&quot;]}</code></pre><h2 id="4-6-创建容器"><a href="#4-6-创建容器" class="headerlink" title="4.6 创建容器"></a>4.6 创建容器</h2><blockquote><p>创建容器并运行</p></blockquote><pre><code>docker run -di --name=tenpower-config -p 12000:12000 192.168.25.129:5000/tenpower-config:1.0-SNAPSHOT</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>案例</title>
      <link href="/2020/03/08/%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/03/08/%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="dockerfile构建jdk8镜像Demo"><a href="#dockerfile构建jdk8镜像Demo" class="headerlink" title="dockerfile构建jdk8镜像Demo"></a>dockerfile构建jdk8镜像Demo</h3><a href="/2020/03/07/Dockerfile/" title="3 dockerfile构建jdk8镜像Demo">3 dockerfile构建jdk8镜像Demo</a>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-常用命令</title>
      <link href="/2020/03/08/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/03/08/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1 文件操作"></a>1 文件操作</h1><h2 id="1-1-创建文件夹"><a href="#1-1-创建文件夹" class="headerlink" title="1.1 创建文件夹"></a>1.1 创建文件夹</h2><blockquote><p>-m&lt;目录属性&gt;或–mode&lt;目录属性&gt; 建立目录时同时设置目录的权限。</p></blockquote><blockquote><p> -p或–parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。</p></blockquote><pre><code>mkdir 文件夹名称</code></pre><h2 id="1-2-创建文件"><a href="#1-2-创建文件" class="headerlink" title="1.2 创建文件"></a>1.2 创建文件</h2><pre><code>（注：Linux下没有文件后缀名区分文件类型之说，系统文件类型只有可执行文件和不可执行文件）touch test.txt vi test.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="/2020/03/07/Dockerfile/"/>
      <url>/2020/03/07/Dockerfile/</url>
      
        <content type="html"><![CDATA[<h1 id="1-dockerfile是什么"><a href="#1-dockerfile是什么" class="headerlink" title="1 dockerfile是什么?"></a>1 dockerfile是什么?</h1><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并终创建一个 新的镜像。</p><pre><code>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；  2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新 的镜像开始工作了；  3、对于运维人员：在部署时，可以实现应用的无缝移植。</code></pre><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2 常用命令"></a>2 常用命令</h1><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件， 将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录,镜像以此目录为绝对路径</td></tr></tbody></table><h1 id="3-dockerfile构建jdk8镜像Demo"><a href="#3-dockerfile构建jdk8镜像Demo" class="headerlink" title="3 dockerfile构建jdk8镜像Demo"></a>3 dockerfile构建jdk8镜像Demo</h1><h2 id="3-1-创建目录"><a href="#3-1-创建目录" class="headerlink" title="3.1 创建目录"></a>3.1 创建目录</h2><pre><code>mkdir -p /usr/local/dockerjdk8</code></pre><h2 id="3-2-下载jdk"><a href="#3-2-下载jdk" class="headerlink" title="3.2 下载jdk"></a>3.2 下载jdk</h2><p>下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中 </p><blockquote><p>资源目录: 統一开发环境\案例_所需资源\dockerfile_构建jdk8镜像Demo</p></blockquote><pre><code>按键: alt + p命令(下载资源):put d:/jdk-8u171-linux-x64.tar.gz</code></pre><h2 id="3-3-创建Dockerfile文件"><a href="#3-3-创建Dockerfile文件" class="headerlink" title="3.3 创建Dockerfile文件"></a>3.3 创建Dockerfile文件</h2><pre><code>// 创建并操作Dockerfile文件内容(注:Dockerfile名字是固定的,不能使用其他名字)vi Dockerfile</code></pre><pre><code># 依赖镜像名称和IDFROM centos:7# 指定镜像创建者信息NLZHMAINTAINER NLZH# 设置工作目录WORKDIR /usr# 所需要运行的命令RUM mkdir /usr/local/java# ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/# 配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH</code></pre><h2 id="3-4-执行镜像"><a href="#3-4-执行镜像" class="headerlink" title="3.4 执行镜像"></a>3.4 执行镜像</h2><blockquote><p>注意:后边的空格和点，不要省略(“.”表示当前目录)</p><p>-t 值是创建新镜像的名称</p></blockquote><pre><code>docker build -t=&#39;jdk1.8&#39; .</code></pre><h2 id="3-5-查看镜像是否建立完成"><a href="#3-5-查看镜像是否建立完成" class="headerlink" title="3.5  查看镜像是否建立完成"></a>3.5  查看镜像是否建立完成</h2><pre><code>docker images</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker应用部署</title>
      <link href="/2020/03/07/docker%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/03/07/docker%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL部署"><a href="#1-MySQL部署" class="headerlink" title="1 MySQL部署"></a>1 MySQL部署</h1><h2 id="1-1-拉取mysql镜像"><a href="#1-1-拉取mysql镜像" class="headerlink" title="1.1 拉取mysql镜像"></a>1.1 拉取mysql镜像</h2><blockquote><p>mysql 5.7版本    </p></blockquote><pre><code>docker pull centos/mysql-57-centos7</code></pre><h2 id="1-2-创建容器"><a href="#1-2-创建容器" class="headerlink" title="1.2 创建容器"></a>1.2 创建容器</h2><pre><code>docker run -di --name=my_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 centos/mysql-57-centos7</code></pre><p>-p 代表端口映射，格式为  宿主机映射端口(CentOS7端口):容器运行端口<br>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p><h2 id="1-3-远程登录mysql"><a href="#1-3-远程登录mysql" class="headerlink" title="1.3 远程登录mysql"></a>1.3 远程登录mysql</h2><p>连接宿主机的IP  ,指定端口为3306 </p><h1 id="2-tomcat部署"><a href="#2-tomcat部署" class="headerlink" title="2 tomcat部署"></a>2 tomcat部署</h1><h2 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h2><pre><code>docker pull tomcat:7-jre7</code></pre><h2 id="2-2-创建容器"><a href="#2-2-创建容器" class="headerlink" title="2.2 创建容器"></a>2.2 创建容器</h2><blockquote><p> 创建容器  -p表示地址映射, centos7映射9000端口, tomcat映射地址 /nlzh/tomcat/webapps</p></blockquote><pre><code>docker run -di --name=mytomcat -p 9000:8080 -v /nlzh/tomcat/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</code></pre><h1 id="3-nginx-部署"><a href="#3-nginx-部署" class="headerlink" title="3 nginx 部署"></a>3 nginx 部署</h1><h2 id="3-1-拉取镜像"><a href="#3-1-拉取镜像" class="headerlink" title="3.1 拉取镜像"></a>3.1 拉取镜像</h2><pre><code>docker pull nginx</code></pre><h2 id="3-2-创建容器"><a href="#3-2-创建容器" class="headerlink" title="3.2 创建容器"></a>3.2 创建容器</h2><pre><code>docker run -di --name=my_nginx -p 80:80 nginx</code></pre><pre><code>// 进入容器docker exec -it my_nginx /bin/bash// 打开nginx目录nginx在目录:   /etc/nginx// 该nginx使用 include,可以加载其他目录上的config配置文件include的文件地址:  /etc/niginx/conf.d/*.conf</code></pre><h1 id="4-Redis部署"><a href="#4-Redis部署" class="headerlink" title="4 Redis部署"></a>4 Redis部署</h1><h2 id="4-1-拉取镜像"><a href="#4-1-拉取镜像" class="headerlink" title="4.1 拉取镜像"></a>4.1 拉取镜像</h2><pre><code>docker pull redis</code></pre><h2 id="4-2-创建容器"><a href="#4-2-创建容器" class="headerlink" title="4.2 创建容器"></a>4.2 创建容器</h2><pre><code>docker run -di --name=my_redis -p 6379:6379 redis</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SecureCRT使用</title>
      <link href="/2020/03/07/SecureCRT%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/07/SecureCRT%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1SecureCRT环境配置"><a href="#1SecureCRT环境配置" class="headerlink" title="1SecureCRT环境配置"></a>1SecureCRT环境配置</h1><h2 id="1-1-配置终端"><a href="#1-1-配置终端" class="headerlink" title="1.1 配置终端"></a>1.1 配置终端</h2><p><img src="/2020/03/07/SecureCRT%E4%BD%BF%E7%94%A8/1.jpg" alt></p><h2 id="2-2-配置编码和字体"><a href="#2-2-配置编码和字体" class="headerlink" title="2.2 配置编码和字体"></a>2.2 配置编码和字体</h2><p><img src="/2020/03/07/SecureCRT%E4%BD%BF%E7%94%A8/2.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VMware-克隆镜像操作</title>
      <link href="/2020/03/07/VMware-%E5%85%8B%E9%9A%86%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/03/07/VMware-%E5%85%8B%E9%9A%86%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="vm克隆一个虚拟机"><a href="#vm克隆一个虚拟机" class="headerlink" title="vm克隆一个虚拟机"></a>vm克隆一个虚拟机</h1><h3 id="1-查看主机信息"><a href="#1-查看主机信息" class="headerlink" title="1 查看主机信息"></a>1 查看主机信息</h3><pre><code>打开cmd, 输入ipconfig查看 IPv4地址  192.168.0.111    默认网关   192.168.0.1</code></pre><p><img src="/2020/03/07/VMware-%E5%85%8B%E9%9A%86%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/1.jpg" alt></p><h3 id="2-进入centos7中修改ip"><a href="#2-进入centos7中修改ip" class="headerlink" title="2 进入centos7中修改ip"></a>2 进入centos7中修改ip</h3><pre><code>cd /etc/sysconfig/network-scripts/vi ifcfg-ens33修改:      BOOTPROTO=static    ONBOOT=yes新增:    IPADDR=192.168.0.146     # 设置ip,前三位和主机网段一致,146这个修改即可,只要不重复    GETWAY=192.168.0.1         #  主机的网关    PREFIX=24保存    shift zz</code></pre><p><img src="/2020/03/07/VMware-%E5%85%8B%E9%9A%86%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/2.png" alt></p><h3 id="3-重启network"><a href="#3-重启network" class="headerlink" title="3 重启network"></a>3 重启network</h3><pre><code>systemctl restart network.service</code></pre><h3 id="4-用主机测试是否ping同虚拟机的ip"><a href="#4-用主机测试是否ping同虚拟机的ip" class="headerlink" title="4 用主机测试是否ping同虚拟机的ip"></a>4 用主机测试是否ping同虚拟机的ip</h3><pre><code>ping 192.168.0.146  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VMware安装和使用</title>
      <link href="/2020/03/07/VMware%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/07/VMware%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-VMWare12版本安装"><a href="#1-VMWare12版本安装" class="headerlink" title="1 VMWare12版本安装"></a>1 VMWare12版本安装</h1><blockquote><p>资源目录:   統一开发环境\java环境搭建\VMware虚拟机</p></blockquote><p><a href="https://blog.csdn.net/qq_25446851/article/details/85610489" target="_blank" rel="noopener">安装教程参考</a></p><h1 id="2-vm克隆一个虚拟机"><a href="#2-vm克隆一个虚拟机" class="headerlink" title="2 vm克隆一个虚拟机"></a>2 vm克隆一个虚拟机</h1><h3 id="2-0-注意事项"><a href="#2-0-注意事项" class="headerlink" title="2.0 注意事项"></a>2.0 注意事项</h3><p>注: 虚拟机要使用桥接模式</p><h3 id="2-1-查看主机信息"><a href="#2-1-查看主机信息" class="headerlink" title="2.1 查看主机信息"></a>2.1 查看主机信息</h3><pre><code>打开cmd, 输入ipconfig查看 IPv4地址  192.168.0.111    默认网关   192.168.0.1</code></pre><p><img src="/2020/03/07/VMware%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/1.jpg" alt></p><h3 id="2-2-进入centos7中修改ip"><a href="#2-2-进入centos7中修改ip" class="headerlink" title="2.2 进入centos7中修改ip"></a>2.2 进入centos7中修改ip</h3><pre><code>cd /etc/sysconfig/network-scripts/vi ifcfg-ens33修改:      BOOTPROTO=static    ONBOOT=yes新增:    IPADDR=192.168.0.146     # 设置ip,前三位和主机网段一致,146这个修改即可,只要不重复    GETWAY=192.168.0.1         #  主机的网关    PREFIX=24保存    shift zz</code></pre><p><img src="/2020/03/07/VMware%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/2.png" alt></p><h3 id="2-3-重启network"><a href="#2-3-重启network" class="headerlink" title="2.3 重启network"></a>2.3 重启network</h3><pre><code>systemctl restart network.service</code></pre><h3 id="2-4-用主机测试是否ping同虚拟机的ip"><a href="#2-4-用主机测试是否ping同虚拟机的ip" class="headerlink" title="2.4 用主机测试是否ping同虚拟机的ip"></a>2.4 用主机测试是否ping同虚拟机的ip</h3><pre><code>ping 192.168.0.146  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VMware安装</title>
      <link href="/2020/03/07/VMware%E5%AE%89%E8%A3%85/"/>
      <url>/2020/03/07/VMware%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="VMWare12版本安装"><a href="#VMWare12版本安装" class="headerlink" title="VMWare12版本安装"></a>VMWare12版本安装</h1><blockquote><p>资源目录:   統一开发环境\java环境搭建\VMware虚拟机</p></blockquote><p><a href="https://blog.csdn.net/qq_25446851/article/details/85610489" target="_blank" rel="noopener">安装教程参考</a></p><h1 id="vm克隆一个虚拟机"><a href="#vm克隆一个虚拟机" class="headerlink" title="vm克隆一个虚拟机"></a>vm克隆一个虚拟机</h1><h3 id="1-查看主机信息"><a href="#1-查看主机信息" class="headerlink" title="1 查看主机信息"></a>1 查看主机信息</h3><pre><code>打开cmd, 输入ipconfig查看 IPv4地址  192.168.0.111    默认网关   192.168.0.1</code></pre><p><img src="/2020/03/07/VMware%E5%AE%89%E8%A3%85/nlzh/%E8%8B%A6%E6%B5%B7%E6%97%A0%E6%B6%AF/xhwy/tool/vm/run/img2/1.jpg" alt></p><h3 id="2-进入centos7中修改ip"><a href="#2-进入centos7中修改ip" class="headerlink" title="2 进入centos7中修改ip"></a>2 进入centos7中修改ip</h3><pre><code>cd /etc/sysconfig/network-scripts/vi ifcfg-ens33修改:      BOOTPROTO=static    ONBOOT=yes新增:    IPADDR=192.168.0.146     # 设置ip,前三位和主机网段一致,146这个修改即可,只要不重复    GETWAY=192.168.0.1         #  主机的网关    PREFIX=24保存    shift zz</code></pre><p><img src="/2020/03/07/VMware%E5%AE%89%E8%A3%85/nlzh/%E8%8B%A6%E6%B5%B7%E6%97%A0%E6%B6%AF/xhwy/tool/vm/run/img2/2.png" alt></p><h3 id="3-重启network"><a href="#3-重启network" class="headerlink" title="3 重启network"></a>3 重启network</h3><pre><code>systemctl restart network.service</code></pre><h3 id="4-用主机测试是否ping同虚拟机的ip"><a href="#4-用主机测试是否ping同虚拟机的ip" class="headerlink" title="4 用主机测试是否ping同虚拟机的ip"></a>4 用主机测试是否ping同虚拟机的ip</h3><pre><code>ping 192.168.0.146  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker入门</title>
      <link href="/2020/03/07/docker%E5%85%A5%E9%97%A8/"/>
      <url>/2020/03/07/docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="docker入门"><a href="#docker入门" class="headerlink" title="docker入门"></a>docker入门</h1><h2 id="1-docker组件"><a href="#1-docker组件" class="headerlink" title="1 docker组件"></a>1 docker组件</h2><h3 id="1-1-docker服务器和客户端"><a href="#1-1-docker服务器和客户端" class="headerlink" title="1.1 docker服务器和客户端"></a>1.1 docker服务器和客户端</h3><pre><code>    Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务 器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提 供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行 Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上 的远程Docker守护进程。</code></pre><h3 id="1-2-docker镜像和容器"><a href="#1-2-docker镜像和容器" class="headerlink" title="1.2 docker镜像和容器"></a>1.2 docker镜像和容器</h3><pre><code>    镜像是构建docker的基石.用户基于镜像来运行自己的容器,容器是基于镜像启动起来的</code></pre><h3 id="1-3-Registry-注册中心"><a href="#1-3-Registry-注册中心" class="headerlink" title="1.3 Registry(注册中心)"></a>1.3 Registry(注册中心)</h3><pre><code>    Docker用Registry(注册中心)来保存用户构建的镜像,Registry分为公共的和私有的两种. Docker公司运营公共的Registry叫Docker Hub. 用户可以在Docker Hub中下载需要的镜像</code></pre><p>Docker Hub网址: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装和使用</title>
      <link href="/2020/03/07/docker%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/07/docker%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1 docker安装"></a>1 docker安装</h1><blockquote><p>官方建议在 Ubuntu中安装</p></blockquote><blockquote><p>安装CentOS7.x版本以上</p></blockquote><h2 id="1-1-yum包更新最新"><a href="#1-1-yum包更新最新" class="headerlink" title="1.1 yum包更新最新"></a>1.1 yum包更新最新</h2><pre><code>sudo yum update</code></pre><h2 id="1-2-安装需要的软件包"><a href="#1-2-安装需要的软件包" class="headerlink" title="1.2 安装需要的软件包"></a>1.2 安装需要的软件包</h2><p>yum-util 提供yum-config-manager功能，另外两个是 devicemapper驱动依赖的</p><pre><code>sudo yum install -y yum-tuils device-mapper-persistent-data lvm2</code></pre><h2 id="1-3-设置yum源为阿里云"><a href="#1-3-设置yum源为阿里云" class="headerlink" title="1.3 设置yum源为阿里云"></a>1.3 设置yum源为阿里云</h2><pre><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><h2 id="1-4-安装docker"><a href="#1-4-安装docker" class="headerlink" title="1.4 安装docker"></a>1.4 安装docker</h2><pre><code>sudo yum install docker-ce</code></pre><h2 id="1-5-查看docker版本"><a href="#1-5-查看docker版本" class="headerlink" title="1.5 查看docker版本"></a>1.5 查看docker版本</h2><pre><code>docker -v</code></pre><h2 id="1-6-设置ustc的镜像"><a href="#1-6-设置ustc的镜像" class="headerlink" title="1.6 设置ustc的镜像"></a>1.6 设置ustc的镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc 的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正 的公共服务。</p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>编辑文件</p><pre><code>vi /etc/docker/daemon.json</code></pre><pre><code>{      &quot;registry‐mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]  }</code></pre><blockquote><p>注:如果有私服,则配置私服</p></blockquote><pre><code>{    &quot;registry-mirrors&quot;:[&quot;https://docker.mirrors.ustc.edu.cn&quot;],    &quot;insecure-registries&quot;:[&quot;192.168.0.201:5000&quot;]}</code></pre><h1 id="2-docker操作"><a href="#2-docker操作" class="headerlink" title="2 docker操作"></a>2 docker操作</h1><h2 id="2-1-启动docker"><a href="#2-1-启动docker" class="headerlink" title="2.1 启动docker"></a>2.1 启动docker</h2><pre><code class="sh">systemctl start docker</code></pre><h2 id="2-2-停止docker"><a href="#2-2-停止docker" class="headerlink" title="2.2 停止docker"></a>2.2 停止docker</h2><pre><code>systemctl stop docker</code></pre><h2 id="2-3-重启docker"><a href="#2-3-重启docker" class="headerlink" title="2.3 重启docker"></a>2.3 重启docker</h2><pre><code>systemctl restart docker</code></pre><h2 id="2-4-查看docker状态"><a href="#2-4-查看docker状态" class="headerlink" title="2.4 查看docker状态"></a>2.4 查看docker状态</h2><pre><code>systemctl status docker</code></pre><h2 id="2-5-开机启动"><a href="#2-5-开机启动" class="headerlink" title="2.5 开机启动"></a>2.5 开机启动</h2><pre><code>systemctl enable docker</code></pre><h2 id="2-6-查看docker概要信息"><a href="#2-6-查看docker概要信息" class="headerlink" title="2.6 查看docker概要信息"></a>2.6 查看docker概要信息</h2><pre><code>docker info</code></pre><h2 id="2-7-查看docker帮助文档"><a href="#2-7-查看docker帮助文档" class="headerlink" title="2.7 查看docker帮助文档"></a>2.7 查看docker帮助文档</h2><pre><code>docker --help</code></pre><h1 id="3-docker镜像操作"><a href="#3-docker镜像操作" class="headerlink" title="3 docker镜像操作"></a>3 docker镜像操作</h1><h2 id="3-1-查看镜像"><a href="#3-1-查看镜像" class="headerlink" title="3.1 查看镜像"></a>3.1 查看镜像</h2><pre><code>docker images</code></pre><p>REPOSITORY：镜像名称<br>TAG：镜像标签(镜像版本)<br>IMAGE ID：镜像ID<br>CREATED：镜像的创建日期（不是获取该镜像的日期）<br>SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p><h2 id="3-2-搜索镜像"><a href="#3-2-搜索镜像" class="headerlink" title="3.2 搜索镜像"></a>3.2 搜索镜像</h2><p>从网络上查询需要的镜像</p><pre><code>docker search 镜像名称</code></pre><p>NAME：仓库名称<br>DESCRIPTION：镜像描述<br>STARS：用户评价，反应一个镜像的受欢迎程度<br>OFFICIAL：是否官方<br>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 </p><h2 id="3-3-拉取镜像"><a href="#3-3-拉取镜像" class="headerlink" title="3.3 拉取镜像"></a>3.3 拉取镜像</h2><p>从中央仓库中下载到本地</p><pre><code>docker pull 镜像名称</code></pre><h2 id="3-4-删除镜像"><a href="#3-4-删除镜像" class="headerlink" title="3.4 删除镜像"></a>3.4 删除镜像</h2><p>按照镜像id删除镜像</p><pre><code>docker rmi 镜像ID</code></pre><p>删除所有镜像</p><pre><code>docker rmi `docker images -q`</code></pre><h1 id="4-容器相关命令"><a href="#4-容器相关命令" class="headerlink" title="4 容器相关命令"></a>4 容器相关命令</h1><h2 id="4-1-查看运行的容器"><a href="#4-1-查看运行的容器" class="headerlink" title="4.1 查看运行的容器"></a>4.1 查看运行的容器</h2><pre><code>docker ps</code></pre><h2 id="4-2-查看所有容器"><a href="#4-2-查看所有容器" class="headerlink" title="4.2 查看所有容器"></a>4.2 查看所有容器</h2><pre><code>docker ps -a</code></pre><h2 id="4-3-查看最后一次运行的容器"><a href="#4-3-查看最后一次运行的容器" class="headerlink" title="4.3 查看最后一次运行的容器"></a>4.3 查看最后一次运行的容器</h2><pre><code>docker ps -l</code></pre><h2 id="4-4-查看停止的容器"><a href="#4-4-查看停止的容器" class="headerlink" title="4.4 查看停止的容器"></a>4.4 查看停止的容器</h2><pre><code>docker ps -f status=exited</code></pre><h2 id="4-5-创建与启动容器"><a href="#4-5-创建与启动容器" class="headerlink" title="4.5 创建与启动容器"></a>4.5 创建与启动容器</h2><p>创建容器常用的参数说明：<br>创建容器命令：</p><pre><code>docker run</code></pre><pre><code> -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分 配一个伪终端。 --name: 为创建的容器命名。  -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），          可以使 用多个－v做多个目录或文件映射。注意：好做目录映射，在宿主机上做修改，然后共 享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会 自动登录容器，      如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做 多个端口映射</code></pre><h3 id="4-5-1-交互式方式创建容器"><a href="#4-5-1-交互式方式创建容器" class="headerlink" title="4.5.1 交互式方式创建容器"></a>4.5.1 交互式方式创建容器</h3><blockquote><p>/bin/bash 表示启动一个bash终端,允许用户交互</p></blockquote><pre><code>docker run -it --name=容器名称 镜像名称:标签 /bin/bash示例:docker run -it --name=my_centos centos:7 /bin/bash</code></pre><p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 </p><blockquote><p>退出当前容器</p></blockquote><pre><code>exit</code></pre><h3 id="4-5-2-守护式方式创建容器"><a href="#4-5-2-守护式方式创建容器" class="headerlink" title="4.5.2 守护式方式创建容器"></a>4.5.2 守护式方式创建容器</h3><blockquote><p>-di  指的是 -i加-d</p></blockquote><pre><code>docker run -di --name=容器名称 镜像名称:标签示例:docker run -di  --name=my_centos2  centos:7</code></pre><p>登录守护式容器方式:</p><blockquote><p>-it 指 -i加上-t</p></blockquote><pre><code>docker exec -it 容器名称(或者容器id) /bin/bash</code></pre><h2 id="4-6-停止与启动容器"><a href="#4-6-停止与启动容器" class="headerlink" title="4.6 停止与启动容器"></a>4.6 停止与启动容器</h2><blockquote><p>停止容器</p></blockquote><pre><code>docker stop 容器名称(或容器id)</code></pre><blockquote><p>启动容器</p></blockquote><pre><code>docker start 容器名称(容器id)</code></pre><h2 id="4-7-删除容器"><a href="#4-7-删除容器" class="headerlink" title="4.7 删除容器"></a>4.7 删除容器</h2><pre><code>docker rm 容器名称(容器id)</code></pre><h2 id="4-8-查看容器IP地址"><a href="#4-8-查看容器IP地址" class="headerlink" title="4.8 查看容器IP地址"></a>4.8 查看容器IP地址</h2><pre><code>docker inspect 容器名称(容器id)</code></pre><blockquote><p>直接输出IP地址</p></blockquote><pre><code>docker inspect --format=&#39;{{.NetworkSettings.IPAddress}}&#39; 容器名称(容器ID)</code></pre><h2 id="4-9-文件拷贝容器"><a href="#4-9-文件拷贝容器" class="headerlink" title="4.9 文件拷贝容器"></a>4.9 文件拷贝容器</h2><blockquote><p> 将文件拷贝到容器内</p></blockquote><pre><code>docker cp 需要拷贝的文件或目录 容器名称:容器目录</code></pre><blockquote><p>也可以将文件从容器内拷贝出来</p></blockquote><pre><code>docker cp 容器名称:容器目录 需要拷贝的文件或目录</code></pre><h2 id="4-10-目录挂载"><a href="#4-10-目录挂载" class="headerlink" title="4.10 目录挂载"></a>4.10 目录挂载</h2><p>目录挂载格式化</p><pre><code> -v参数 宿主机目录:容器目录</code></pre><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可 以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为   宿主机目录:容器目录</p><pre><code>docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7</code></pre><p>如果你共享的是多级的目录，可能会出现权限不足的提示。<br>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  -privileged=true  来解决挂载的目录没有权限的问题 </p><h1 id="5-迁移和备份"><a href="#5-迁移和备份" class="headerlink" title="5 迁移和备份"></a>5 迁移和备份</h1><h2 id="5-1-容器保存为镜像"><a href="#5-1-容器保存为镜像" class="headerlink" title="5.1 容器保存为镜像"></a>5.1 容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像</p><pre><code>docker commit mynginx mynginx_i</code></pre><h2 id="5-2-镜像备份"><a href="#5-2-镜像备份" class="headerlink" title="5.2 镜像备份"></a>5.2 镜像备份</h2><pre><code>docker save -o mynginx.tar mynginx_i</code></pre><h2 id="5-3-镜像恢复与迁移"><a href="#5-3-镜像恢复与迁移" class="headerlink" title="5.3 镜像恢复与迁移"></a>5.3 镜像恢复与迁移</h2><p>首先我们先删除掉mynginx_img镜像  然后执行此命令进行恢复</p><pre><code>docker load -i mynginx.tar</code></pre><p>-i 输入的文件</p><p>执行后再次查看镜像,可以看到镜像已经恢复</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="/2020/03/06/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/03/06/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装node技术"><a href="#1-安装node技术" class="headerlink" title="1 安装node技术"></a>1 安装node技术</h2><p> <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener"> https://nodejs.org/zh-cn/ </a> </p><h2 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2 安装git"></a>2 安装git</h2><p>参考git安装</p><h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3 安装hexo"></a>3 安装hexo</h2><pre><code class="shell">// 全局安装hexonpm install hexo-cli -g// 创建&quot;blog&quot;博客项目hexo init blog// 进入博客项目cd blog// 安装依赖npm install// 安装git部署插件npm install --save hexo-deployer-git// 安装图片上传插件npm install hexo-asset-image --save// 安装背景git clone https://github.com/litten/hexo-theme-yilia themes/yilia// yilia所需插件npm i hexo-generator-json-content --save</code></pre><h2 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4 修改配置文件"></a>4 修改配置文件</h2><blockquote><p>nlzh_1 修改名称:  虞奥飞的博客</p><p>nlzh_2 修改副名称: nlzh blog</p><p>nlzh_3 修改作者</p><p>nlzh_4 修改网址,注:如果博客在子目录需要配置子目录</p><p>nlzh_5 设置资源文件夹</p><p>nlzh_6 修改背景 yilia</p><p>nlzh_7 修改github上传地址</p><p>nlzh_8 yiliya所需配置</p></blockquote><pre><code># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site# nlzh_1 修改名称:title: 虞奥飞的博客# nlzh_2 修改副名称subtitle: nlzh blogdescription: &#39;&#39;keywords:# nlzh_3 修改作者author: nlzhlanguage: entimezone: &#39;&#39;# URL## nlzh_4 如果您的网站位于子目录中，则将url设置为“ http://yoursite.com/child”，将根目录设置为“ / child /”url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#39;&#39;filename_case: 0render_drafts: false# nlzh_5 设置资源文件夹(true),用于存放图片post_asset_folder: truerelative_link: falsefuture: truehighlight:  enable: true  line_number: true  auto_detect: false  tab_replace: &#39;&#39;  wrap: true  hljs: false# Home page setting# path: Root path for your blogs index page. (default = &#39;&#39;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#39;&#39;  per_page: 10  order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post&#39;s date for updated date unless set in front-matteruse_date_for_updated: false# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#39;source/&#39; folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/## nlzh_6 修改背景theme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.html# nlzh_7 修改github上传地址deploy:  type: git  repo: https://github.com/1352148827/1352148827.github.io.git  branch: master# nlzh_8 yilia 所需配置jsonContent:    meta: false    pages: false    posts:      title: true      date: true      path: true      text: false      raw: false      content: false      slug: false      updated: false      comments: false      link: false      permalink: false      excerpt: false      categories: false      tags: true</code></pre><h2 id="5-修改yilia配置"><a href="#5-修改yilia配置" class="headerlink" title="5 修改yilia配置"></a>5 修改yilia配置</h2><p>进入themes/yilia/_config.yml</p><blockquote><p>添加头像: 找一张图片放到以下目录即可: themes/yilia/source/img/avatar.jpg</p></blockquote><blockquote><p>修改路径: 如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，请将您的">http://yoursite.com/blog，请将您的</a> url 设为 <a href="http://yoursite.com/blog">http://yoursite.com/blog</a> 并把 root 设为 /blog/。</p></blockquote><pre><code># Headermenu:  主页: /# SubNavsubnav:  #github: &quot;#&quot;  #weibo: &quot;#&quot;  #rss: &quot;#&quot;  #zhihu: &quot;#&quot;  #qq: &quot;#&quot;  #weixin: &quot;#&quot;  #jianshu: &quot;#&quot;  #douban: &quot;#&quot;  #segmentfault: &quot;#&quot;  #bilibili: &quot;#&quot;  #acfun: &quot;#&quot;  #mail: &quot;mailto:litten225@qq.com&quot;  #facebook: &quot;#&quot;  #google: &quot;#&quot;  #twitter: &quot;#&quot;  #linkedin: &quot;#&quot;rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: /# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &#39;展开全文&#39;# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 0# 打赏wordingreward_wording: &#39;谢谢你请我吃糖果&#39;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 2# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: false# 目录为空时的提示toc_empty_wording: &#39;目录，不存在的…&#39;# 是否有快速回到顶部的按钮top: true# Miscellaneousbaidu_analytics: &#39;&#39;google_analytics: &#39;&#39;favicon: /favicon.png#你的头像url,注:全路径(在themes/ylia/source/img/avatar.jpg)avatar: https://xxx.xxx.io/blog/img/avatar.jpg#是否开启分享share_jia: true#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment#不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: falsechangyan_conf: false#4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false#5、Gitmentgitment_owner: false      #你的 GitHub IDgitment_repo: &#39;&#39;          #存储评论的 repogitment_oauth:  client_id: &#39;&#39;           #client ID  client_secret: &#39;&#39;       #client secret# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style:  # 头像上面的背景颜色  header: &#39;#4d4d4d&#39;  # 右滑板块背景  slider: &#39;linear-gradient(200deg,#a0cfe4,#e8c37e)&#39;# slider的设置slider:  # 是否默认展开tags板块  showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:#  friends: falsesmart_menu:  innerArchive: &#39;所有文章&#39;  friends: false  aboutme: falsefriends:  友情链接1: http://localhost:4000/  友情链接2: http://localhost:4000/aboutme: 很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</code></pre><h2 id="6-修改yilia请求"><a href="#6-修改yilia请求" class="headerlink" title="6 修改yilia请求"></a>6 修改yilia请求</h2><pre><code>themes\yilia\source-src\js\report.js 目录themes\yilia\source\main.0cf68a.js 目录修改 //litten.me:9005/badjs/ 为 //localhost</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-12-谷歌安装vue-devtool插件</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-0-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-0-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="谷歌安装vue-devtool插件"><a href="#谷歌安装vue-devtool插件" class="headerlink" title="谷歌安装vue-devtool插件"></a>谷歌安装vue-devtool插件</h1><h2 id="1-下载插件"><a href="#1-下载插件" class="headerlink" title="1 下载插件"></a>1 下载插件</h2><pre><code>git clone https://github.com/vuejs/vue-devtools.git</code></pre><h2 id="2-安装依赖js"><a href="#2-安装依赖js" class="headerlink" title="2 安装依赖js"></a>2 安装依赖js</h2><pre><code>cd vue-devtools-devcnpm install</code></pre><h2 id="3-编译"><a href="#3-编译" class="headerlink" title="3 编译"></a>3 编译</h2><pre><code>npm run build</code></pre><h2 id="4-修改配置"><a href="#4-修改配置" class="headerlink" title="4 修改配置"></a>4 修改配置</h2><blockquote><p>进入 vue-devtools-dev&gt;shells&gt;chrome&gt;manifest.json </p><p>将  persistent的value值改为true</p></blockquote><p><img src="/2020/03/06/vue%E5%9F%BA%E7%A1%80-0-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/1.jpg" alt></p><h2 id="5-谷歌安装插件"><a href="#5-谷歌安装插件" class="headerlink" title="5 谷歌安装插件"></a>5 谷歌安装插件</h2><pre><code>打开chrome浏览器，打开更多工具&gt;扩展程序；再点击加载已解压的扩展程序，然后把shells&gt;chrome文件夹放入</code></pre><p><img src="/2020/03/06/vue%E5%9F%BA%E7%A1%80-0-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/2.jpg" alt></p><h2 id="6-测试安装"><a href="#6-测试安装" class="headerlink" title="6 测试安装"></a>6 测试安装</h2><pre><code>在插件的目录下执行npm run dev，这个时候我们的插件就可以运行了,打开localhost:8080可以看到插件已经安装并运行了。</code></pre><p><img src="/2020/03/06/vue%E5%9F%BA%E7%A1%80-0-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/3.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-1-vue介绍</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-1-vue%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-1-vue%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="vue介绍"><a href="#vue介绍" class="headerlink" title="vue介绍"></a>vue介绍</h1><h2 id="1-什么是vue"><a href="#1-什么是vue" class="headerlink" title="1 什么是vue?"></a>1 什么是vue?</h2><pre><code>vuejs是一个渐进式javascript框架</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-10-vue动画</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-10-vue%E5%8A%A8%E7%94%BB/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-10-vue%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue中的动画"><a href="#Vue中的动画" class="headerlink" title="Vue中的动画"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Vue中的动画</a></h2><p><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Vue中的动画参考</a></p><p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p><h3 id="1-使用过渡类名"><a href="#1-使用过渡类名" class="headerlink" title="1 使用过渡类名"></a>1 使用过渡类名</h3><ol><li><p>HTML结构：</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt;         &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;         &lt;transition name=&quot;fade&quot;&gt;           &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;         &lt;/transition&gt;       &lt;/div&gt;</code></pre></li><li><p>VM 实例：</p><pre><code>     // 创建 Vue 实例，得到 ViewModel     var vm = new Vue({       el: &#39;#app&#39;,       data: {         isshow: false       },       methods: {         myAnimate() {           this.isshow = !this.isshow;         }       }     });</code></pre></li><li><p>定义两组类样式：</p><pre><code>     /* 定义进入和离开时候的过渡状态 */         .fade-enter-active,         .fade-leave-active {           transition: all 0.2s ease;           position: absolute;         }         /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */         .fade-enter,         .fade-leave-to {           opacity: 0;           transform: translateX(100px);         }</code></pre></li></ol><h3 id="2-使用第三方-CSS-动画库"><a href="#2-使用第三方-CSS-动画库" class="headerlink" title="2 使用第三方 CSS 动画库"></a>2 使用第三方 CSS 动画库</h3><p><a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名" target="_blank" rel="noopener">使用第三方 CSS 动画库参考</a></p><ol><li><p>导入动画类库：</p><pre><code>     &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt;</code></pre></li><li><p>定义 transition 及属性：</p><pre><code>     &lt;transition         enter-active-class=&quot;fadeInRight&quot;         leave-active-class=&quot;fadeOutRight&quot;         :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt;           &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;     &lt;/transition&gt;</code></pre></li></ol><h3 id="3-使用动画钩子函数"><a href="#3-使用动画钩子函数" class="headerlink" title="3 使用动画钩子函数"></a>3 使用动画钩子函数</h3><ol><li><p>定义 transition 组件以及三个钩子函数：</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt;         &lt;transition         @before-enter=&quot;beforeEnter&quot;         @enter=&quot;enter&quot;         @after-enter=&quot;afterEnter&quot;&gt;           &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt;         &lt;/transition&gt;       &lt;/div&gt;</code></pre></li><li><p>定义三个 methods 钩子方法：</p><pre><code>     methods: {             beforeEnter(el) { // 动画进入之前的回调               el.style.transform = &#39;translateX(500px)&#39;;             },             enter(el, done) { // 动画进入完成时候的回调               el.offsetWidth;               el.style.transform = &#39;translateX(0px)&#39;;               done();             },             afterEnter(el) { // 动画进入完成之后的回调               this.isshow = !this.isshow;             }           }</code></pre></li><li><p>定义动画过渡时长和样式：</p><pre><code>     .show{       transition: all 0.4s ease;     }</code></pre></li></ol><h3 id="4-v-for-的列表过渡"><a href="#4-v-for-的列表过渡" class="headerlink" title="4 v-for 的列表过渡"></a>4 v-for 的列表过渡</h3><p><a href="https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡" target="_blank" rel="noopener">v-for列表的过渡参考</a></p><ol><li><p>定义过渡样式：</p><pre><code>     &lt;style&gt;         .list-enter,         .list-leave-to {           opacity: 0;           transform: translateY(10px);         }         .list-enter-active,         .list-leave-active {           transition: all 0.3s ease;         }     &lt;/style&gt;</code></pre></li><li><p>定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：</p><pre><code>       &lt;div id=&quot;app&quot;&gt;         &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt;         &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt;           &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;{{item}}&lt;/li&gt;         &lt;/transition-group&gt;       &lt;/div&gt;</code></pre></li><li><p>定义 VM中的结构：</p><pre><code>     // 创建 Vue 实例，得到 ViewModel     var vm = new Vue({       el: &#39;#app&#39;,       data: {         txt: &#39;&#39;,         list: [1, 2, 3, 4]       },       methods: {         add() {           this.list.push(this.txt);           this.txt = &#39;&#39;;         }       }     });</code></pre></li></ol><h3 id="5-列表的排序过渡"><a href="#5-列表的排序过渡" class="headerlink" title="5 列表的排序过渡"></a>5 列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p><ul><li><p><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：</p><pre><code>      .v-move{        transition: all 0.8s ease;      }      .v-leave-active{        position: absolute;      }</code></pre></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol><li><a href="https://v1-cn.vuejs.org/" target="_blank" rel="noopener">vue.js 1.x 文档</a></li><li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js 2.x 文档</a></li><li><a href="http://www.css88.com/archives/7715" target="_blank" rel="noopener">String.prototype.padStart(maxLength, fillString)</a></li><li><a href="http://www.cnblogs.com/wuhua1/p/6686237.html" target="_blank" rel="noopener">js 里面的键盘事件对应的键码</a></li><li><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">pagekit/vue-resource</a></li><li><a href="https://jingyan.baidu.com/article/a65957f4976aad24e67f9b9b.html" target="_blank" rel="noopener">navicat如何导入sql文件和导出sql文件</a></li><li><a href="http://cubic-bezier.com/#.4,-0.3,1,.33" target="_blank" rel="noopener">贝塞尔在线生成器</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-12-谷歌安装vue-devtool插件</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-12-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-12-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="谷歌安装vue-devtool插件"><a href="#谷歌安装vue-devtool插件" class="headerlink" title="谷歌安装vue-devtool插件"></a>谷歌安装vue-devtool插件</h1><h2 id="1-下载插件"><a href="#1-下载插件" class="headerlink" title="1 下载插件"></a>1 下载插件</h2><pre><code>git clone https://github.com/vuejs/vue-devtools.git</code></pre><h2 id="2-安装依赖js"><a href="#2-安装依赖js" class="headerlink" title="2 安装依赖js"></a>2 安装依赖js</h2><pre><code>cd vue-devtools-devcnpm install</code></pre><h2 id="3-编译"><a href="#3-编译" class="headerlink" title="3 编译"></a>3 编译</h2><pre><code>npm run build</code></pre><h2 id="4-修改配置"><a href="#4-修改配置" class="headerlink" title="4 修改配置"></a>4 修改配置</h2><blockquote><p>进入 vue-devtools-dev&gt;shells&gt;chrome&gt;manifest.json </p><p>将  persistent的value值改为true</p></blockquote><p><img src="/2020/03/06/vue%E5%9F%BA%E7%A1%80-12-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/1.jpg" alt></p><h2 id="5-谷歌安装插件"><a href="#5-谷歌安装插件" class="headerlink" title="5 谷歌安装插件"></a>5 谷歌安装插件</h2><pre><code>打开chrome浏览器，打开更多工具&gt;扩展程序；再点击加载已解压的扩展程序，然后把shells&gt;chrome文件夹放入</code></pre><p><img src="/2020/03/06/vue%E5%9F%BA%E7%A1%80-12-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/2.jpg" alt></p><h2 id="6-测试安装"><a href="#6-测试安装" class="headerlink" title="6 测试安装"></a>6 测试安装</h2><pre><code>在插件的目录下执行npm run dev，这个时候我们的插件就可以运行了,打开localhost:8080可以看到插件已经安装并运行了。</code></pre><p><img src="/2020/03/06/vue%E5%9F%BA%E7%A1%80-12-%E8%B0%B7%E6%AD%8C%E5%AE%89%E8%A3%85vue-devtool%E6%8F%92%E4%BB%B6/3.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-4-过滤器</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-4-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-4-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p><h3 id="1-私有过滤器"><a href="#1-私有过滤器" class="headerlink" title="1 私有过滤器"></a>1 私有过滤器</h3><ol><li>HTML元素使用过滤器：</li></ol><pre><code class="html">            &lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt;</code></pre><ol start="2"><li>vue中私有 <code>filters</code> 定义方式：</li></ol><pre><code class="js">    filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用    dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错      var dt = new Date(input);      // 获取年月日      var y = dt.getFullYear();      var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);      var d = dt.getDate().toString().padStart(2, &#39;0&#39;);      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日      // 否则，就返回  年-月-日 时：分：秒      if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) {        return `${y}-${m}-${d}`;      } else {        // 获取时分秒        var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);        var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);        var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;      }    }  }</code></pre><blockquote><p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p></blockquote><h3 id="2-全局过滤器"><a href="#2-全局过滤器" class="headerlink" title="2 全局过滤器"></a>2 全局过滤器</h3><pre><code class="js">        // 定义一个全局过滤器        Vue.filter(&#39;dataFormat&#39;, function (input, pattern = &#39;&#39;) {          var dt = new Date(input);          // 获取年月日          var y = dt.getFullYear();          var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);          var d = dt.getDate().toString().padStart(2, &#39;0&#39;);          // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日          // 否则，就返回  年-月-日 时：分：秒          if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) {            return `${y}-${m}-${d}`;          } else {            // 获取时分秒            var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);            var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);            var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);            return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;          }        });</code></pre><blockquote><p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-2-vue的指令</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-2-vue%E7%9A%84%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-2-vue%E7%9A%84%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="vue的指令"><a href="#vue的指令" class="headerlink" title="vue的指令"></a>vue的指令</h1><pre><code>指令    v-cloak: 插值指令    v-text: 插值指令    v-bind: 属性绑定指令(可以简写为在属性前加:, 示例: &lt;div :class=&quot;xxx&quot;/&gt;)    v-on:   事件绑定指令(可以简写为在事件前加@, 示例: &lt;button @click=&quot;btn&quot; /&gt;)    v-model: 双向数据绑定样式        -- 通过两种方式对样式进行修改,1 控制class属性, 2 控制style属性    使用class样式,可以通过集中方式对class进行赋值(数组,对象,三元表达式)    使用内联样式(style), 可以直接将样式赋予原始</code></pre><h2 id="1-vue的结构"><a href="#1-vue的结构" class="headerlink" title="1 vue的结构"></a>1 vue的结构</h2><pre><code class="html">        &lt;style&gt;            [v-cloak] {              display: none;             }         &lt;/style&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;p v-cloak&gt;${{ msg}}&lt;/p&gt;            &lt;h4 v-text=&quot;msg&quot; &gt;&lt;/h4&gt;             &lt;input type=&quot;button&quot; value=&quot;开启&quot; v-on:click=&quot;go&quot;&gt;            &lt;input type=&quot;button&quot; value=&quot;停止&quot; v-on:click=&quot;stop&quot;&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../../lib/vue/vue-2.4.0.js&quot; &gt;&lt;/script&gt;        &lt;script&gt;            var vm = new Vue({                el: &#39;#app&#39;,                data:{                    msg:&#39;123&#39;                }            })        &lt;/script&gt;</code></pre><h2 id="2-vue的指令"><a href="#2-vue的指令" class="headerlink" title="2 vue的指令"></a>2 vue的指令</h2><h3 id="2-1-v-cloak和v-text-插值指令"><a href="#2-1-v-cloak和v-text-插值指令" class="headerlink" title="2.1 v-cloak和v-text  (插值指令)"></a>2.1 v-cloak和v-text  (插值指令)</h3><p>v-cloak和v-text都是用作给标签赋值</p><pre><code>            v-cloak:                 缺点：有闪烁问题，在网速慢的情况下会把 ${{msg}}显露出来，需要css处理下                优点：可以在元素体拼接其他字符串            v-text：                优点：没有闪烁问题，直接用                缺点：不可用和其他字符串拼接</code></pre><h3 id="2-2-v-html-模板指令"><a href="#2-2-v-html-模板指令" class="headerlink" title="2.2 v-html  (模板指令)"></a>2.2 v-html  (模板指令)</h3><p>v-html 相当于jquery的append（）方法，输入html字符串生成html标签</p><p><code>&lt;h4 v-html=&quot;msg&quot; &gt;&lt;/h4&gt;</code></p><h3 id="2-3-v-bind-属性绑定指令"><a href="#2-3-v-bind-属性绑定指令" class="headerlink" title="2.3 v-bind (属性绑定指令 )"></a>2.3 v-bind (属性绑定指令 )</h3><ul><li><p>绑定属性 这样title属性的值为vue的data参数的myTitle</p><pre><code>  ```</code></pre><p>  全写方式: <input type="button" v-bind:title="myTitle" value="开启"><br>  简写方式: &lt;input type=”button”:title=”myTitle” value=”开启” &gt;</p><pre><code></code></pre></li></ul><p>​        </p><h3 id="2-4-v-on-事件绑定指令"><a href="#2-4-v-on-事件绑定指令" class="headerlink" title="2.4 v-on (事件绑定指令 )"></a>2.4 v-on (事件绑定指令 )</h3><pre><code>正常写法：&lt;input type=&quot;button&quot; value=&quot;开启&quot; v-on:click=&quot;go&quot;&gt;&lt;br/&gt;简写方式：&lt;input type=&quot;button&quot; value=&quot;停止&quot; @click=&quot;stop&quot;&gt;</code></pre><h3 id="2-5-事件修饰符"><a href="#2-5-事件修饰符" class="headerlink" title="2.5 事件修饰符"></a>2.5 事件修饰符</h3><ul><li><p>.stop       阻止冒泡</p></li><li><p>.prevent    阻止默认事件</p></li><li><p>.capture    添加事件侦听器时使用事件捕获模式</p></li><li><p>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</p></li><li><p>.once       事件只触发一次</p></li></ul><h3 id="2-6-v-model-双向数据绑定"><a href="#2-6-v-model-双向数据绑定" class="headerlink" title="2.6 v-model (双向数据绑定)"></a>2.6 v-model (双向数据绑定)</h3><p>双向数据绑定：就是你表单的数据进行修改，同时会更新你vue对象data中对应的属性的值</p><pre><code> &lt;!-- v-model 只能运用在 表单元素中 --&gt; &lt;input type=&quot;text&quot; style=&quot;width:100%;&quot; v-model=&quot;msg&quot;&gt;</code></pre><h2 id="3-在Vue中使用样式"><a href="#3-在Vue中使用样式" class="headerlink" title="3 在Vue中使用样式"></a>3 在Vue中使用样式</h2><h3 id="3-1-使用class样式"><a href="#3-1-使用class样式" class="headerlink" title="3.1 使用class样式"></a>3.1 使用class样式</h3><blockquote><p>class属性跟vue绑定</p></blockquote><ol><li><p>数组</p><pre><code> ```html &lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre><pre><code></code></pre></li></ol><ol start="2"><li><p>数组中使用三元表达式</p><pre><code> ```html &lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre><pre><code> ​    </code></pre></li></ol><ol start="3"><li><p>数组中嵌套对象</p><pre><code> ```html &lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;, {&#39;active&#39;: isactive}]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre><pre><code> ​    </code></pre></li></ol><ol start="4"><li><p>直接使用对象</p><pre><code> ```html &lt;h1 :class=&quot;{red:true, italic:true, active:true, thin:true}&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre><pre><code> ​    </code></pre></li></ol><h3 id="3-2-使用内联样式"><a href="#3-2-使用内联样式" class="headerlink" title="3.2 使用内联样式"></a>3.2 使用内联样式</h3><ol><li>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</li></ol><pre><code class="html">    &lt;h1 :style=&quot;{color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;}&quot;&gt;这是一个善良的H1&lt;/h1&gt;</code></pre><ol start="2"><li><p>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</p><ul><li><p>在data上定义样式：</p><pre><code class="css">data: {    h1StyleObj: { color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; }}</code></pre></li></ul></li></ol><ul><li><p>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</p><pre><code>     ```html     &lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt;</code></pre><pre><code> ​        </code></pre></li></ul><ol start="3"><li>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象<ul><li>在data上定义样式：</li></ul></li></ol><pre><code class="css">        data: {                h1StyleObj: { color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; },                h1StyleObj2: { fontStyle: &#39;italic&#39; }        }</code></pre><ul><li><p>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</p><pre><code>     ```html     &lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt;</code></pre><pre><code> ​        </code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-3-vue的for循环和if判断指令</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-3-vue%E7%9A%84for%E5%BE%AA%E7%8E%AF%E5%92%8Cif%E5%88%A4%E6%96%AD%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-3-vue%E7%9A%84for%E5%BE%AA%E7%8E%AF%E5%92%8Cif%E5%88%A4%E6%96%AD%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue指令之v-for和key属性"><a href="#Vue指令之v-for和key属性" class="headerlink" title="Vue指令之v-for和key属性"></a>Vue指令之<code>v-for</code>和<code>key</code>属性</h2><ol><li>迭代数组</li></ol><pre><code class="html">        &lt;ul&gt;             &lt;li v-for=&quot;(item, i) in list&quot;&gt;                索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}            &lt;/li&gt;        &lt;/ul&gt;</code></pre><ol start="2"><li>迭代对象中的属性</li></ol><pre><code class="html">    &lt;!-- 循环遍历对象身上的属性 --&gt;    &lt;div v-for=&quot;(val, key, i) in userInfo&quot;&gt;{{val}} --- {{key}} --- {{i}}&lt;/div&gt;</code></pre><ol start="3"><li>迭代数字</li></ol><pre><code class="html">        &lt;p v-for=&quot;i in 10&quot;&gt;这是第 {{i}} 个P标签&lt;/p&gt;</code></pre><blockquote><p>2.2.0+ 的版本里，<strong>当在组件中使用</strong> v-for 时，key 现在是必须的。</p></blockquote><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p><h2 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h2><blockquote><p>v-if指令: 当判断为true时生成div,false时删除div</p><p>v-show指令: 当判断为true时显示div,false时隐藏div</p><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p></blockquote><pre><code class="html">&lt;div v-if=&quot;true&quot;&gt; 这是if判断&lt;/div&gt;&lt;div v-show:&quot;true&quot;&gt;这是show判断&lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-5-按键修饰符</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-5-%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-5-%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id="1-中自定义键盘修饰符【了解即可】"><a href="#1-中自定义键盘修饰符【了解即可】" class="headerlink" title="1. 中自定义键盘修饰符【了解即可】"></a>1. 中自定义键盘修饰符【了解即可】</h3><pre><code class="js">    Vue.directive(&#39;on&#39;).keyCodes.f2 = 113;</code></pre><h3 id="2-x中自定义键盘修饰符"><a href="#2-x中自定义键盘修饰符" class="headerlink" title="2.x中自定义键盘修饰符"></a><a href="https://cn.vuejs.org/v2/guide/events.html#键值修饰符" target="_blank" rel="noopener">2.x中自定义键盘修饰符</a></h3><ol><li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li></ol><pre><code>    Vue.config.keyCodes.f2 = 113;</code></pre><ol start="2"><li>使用自定义的按键修饰符：</li></ol><pre><code>    &lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-7-vue的生命周期</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-7-vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-7-vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="vue实例的生命周期"><a href="#vue实例的生命周期" class="headerlink" title="vue实例的生命周期"></a>vue实例的生命周期</h1><p><a href="https://cn.vuejs.org/v2/guide/instance.html#实例生命周期" target="_blank" rel="noopener">vue实例的生命周期详解</a></p><h2 id="1-什么是声明周期"><a href="#1-什么是声明周期" class="headerlink" title="1 什么是声明周期"></a>1 什么是声明周期</h2><pre><code>从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</code></pre><p><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</p><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p><h2 id="2-主要的生命周期函数分类"><a href="#2-主要的生命周期函数分类" class="headerlink" title="2 主要的生命周期函数分类"></a>2 主要的生命周期函数分类</h2><pre><code>1 创建期间的生命周期函数：   1.1 beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性   1.2 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板   1.3 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中   1.4 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示2 运行期间的生命周期函数：   2.1 beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点   2.2 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！3 销毁期间的生命周期函数：   3.1 beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。   3.2 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</code></pre><h2 id="3-图解声明周期"><a href="#3-图解声明周期" class="headerlink" title="3 图解声明周期"></a>3 图解声明周期</h2><p><img src="/2020/03/06/vue%E5%9F%BA%E7%A1%80-7-vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-6-自定义指令</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令参考资料</a></p><h2 id="1-自定义指令的参数详解"><a href="#1-自定义指令的参数详解" class="headerlink" title="1 自定义指令的参数详解"></a>1 自定义指令的参数详解</h2><pre><code>* el：指令所绑定的元素，可以用来直接操作 DOM 。* binding：一个对象，包含以下属性：    * name：指令名，不包括 v- 前缀。    * value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。    * oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。                无论值是否改变都可用。    * expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot;中，表达式为 &quot;1 + 1&quot;。    * arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。    * modifiers：一个包含修饰符的对象。                例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。    * vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。    * oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</code></pre><h2 id="2-自定义全局的指令"><a href="#2-自定义全局的指令" class="headerlink" title="2 自定义全局的指令"></a>2 自定义全局的指令</h2><pre><code class="js">    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：    Vue.directive(&#39;focus&#39;, {      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用        el.focus();      }    });</code></pre><h2 id="3-自定义局部的指令"><a href="#3-自定义局部的指令" class="headerlink" title="3 自定义局部的指令"></a>3 自定义局部的指令</h2><pre><code class="js">    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：      directives: {        color: { // 为元素设置指定的字体颜色          bind(el, binding) {// el表示元素,bingding调用时传的参数            el.style.color = binding.value;          }        },        &#39;font-weight&#39;: function (el, binding2) {             // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数          el.style.fontWeight = binding2.value;        }      }</code></pre><h2 id="4-自定义指令的使用方式"><a href="#4-自定义指令的使用方式" class="headerlink" title="4 自定义指令的使用方式"></a>4 自定义指令的使用方式</h2><pre><code class="html">    &lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&#39;red&#39;&quot; v-font-weight=&quot;900&quot;&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-10-vue动画</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-11-vue%E8%B7%AF%E7%94%B1%E6%8F%92%E4%BB%B6/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-11-vue%E8%B7%AF%E7%94%B1%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><ol><li><p><strong>后端路由：</strong>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p></li><li><p><strong>前端路由：</strong>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p></li><li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p></li></ol><h2 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h2><ol><li><p>导入 vue-router 组件类库：</p><pre><code>     &lt;!-- 1. 导入 vue-router 组件类库 --&gt;       &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>使用 router-link 组件来导航</p><pre><code>     &lt;!-- 2. 使用 router-link 组件来导航 --&gt;     &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;     &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;</code></pre></li><li><p>使用 router-view 组件来显示匹配到的组件</p><pre><code>     &lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;     &lt;router-view&gt;&lt;/router-view&gt;</code></pre></li><li><p>创建使用<code>Vue.extend</code>创建组件</p><pre><code>     // 4.1 使用 Vue.extend 来创建登录组件     var login = Vue.extend({       template: &#39;&lt;h1&gt;登录组件&lt;/h1&gt;&#39;     });     // 4.2 使用 Vue.extend 来创建注册组件     var register = Vue.extend({       template: &#39;&lt;h1&gt;注册组件&lt;/h1&gt;&#39;     });</code></pre></li><li><p>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p><pre><code>     // 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则         var router = new VueRouter({           routes: [             { path: &#39;/login&#39;, component: login },             { path: &#39;/register&#39;, component: register }           ]         });</code></pre></li><li><p>使用 router 属性来使用路由规则</p><pre><code>     // 6. 创建 Vue 实例，得到 ViewModel         var vm = new Vue({           el: &#39;#app&#39;,           router: router // 使用 router 属性来使用路由规则         });</code></pre></li></ol><h2 id="使用tag属性指定router-link渲染的标签类型"><a href="#使用tag属性指定router-link渲染的标签类型" class="headerlink" title="使用tag属性指定router-link渲染的标签类型"></a>使用tag属性指定router-link渲染的标签类型</h2><h2 id="设置路由重定向"><a href="#设置路由重定向" class="headerlink" title="设置路由重定向"></a>设置路由重定向</h2><h2 id="设置路由高亮"><a href="#设置路由高亮" class="headerlink" title="设置路由高亮"></a>设置路由高亮</h2><h2 id="设置路由切换动效"><a href="#设置路由切换动效" class="headerlink" title="设置路由切换动效"></a>设置路由切换动效</h2><h2 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h2><ol><li><p>在规则中定义参数：</p><pre><code>     { path: &#39;/register/:id&#39;, component: register }</code></pre></li><li><p>通过 <code>this.$route.params</code>来获取路由中的参数：</p><pre><code>     var register = Vue.extend({           template: &#39;&lt;h1&gt;注册组件 --- {{this.$route.params.id}}&lt;/h1&gt;&#39;         });</code></pre></li></ol><h2 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h2><pre><code>          &lt;div id=&quot;app&quot;&gt;            &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt;            &lt;router-view&gt;&lt;/router-view&gt;          &lt;/div&gt;          &lt;script&gt;            // 父路由中的组件            const account = Vue.extend({              template: `&lt;div&gt;                这是account组件                &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; |                 &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt;                &lt;router-view&gt;&lt;/router-view&gt;              &lt;/div&gt;`            });            // 子路由中的 login 组件            const login = Vue.extend({              template: &#39;&lt;div&gt;登录组件&lt;/div&gt;&#39;            });            // 子路由中的 register 组件            const register = Vue.extend({              template: &#39;&lt;div&gt;注册组件&lt;/div&gt;&#39;            });            // 路由实例            var router = new VueRouter({              routes: [                { path: &#39;/&#39;, redirect: &#39;/account/login&#39; }, // 使用 redirect 实现路由重定向                {                  path: &#39;/account&#39;,                  component: account,                  children: [ // 通过 children 数组属性，来实现路由的嵌套                    { path: &#39;login&#39;, component: login }, // 注意，子路由的开头位置，不要加 / 路径符                    { path: &#39;register&#39;, component: register }                  ]                }              ]            });            // 创建 Vue 实例，得到 ViewModel            var vm = new Vue({              el: &#39;#app&#39;,              data: {},              methods: {},              components: {                account              },              router: router            });          &lt;/script&gt;</code></pre><h2 id="命名视图实现经典布局"><a href="#命名视图实现经典布局" class="headerlink" title="命名视图实现经典布局"></a>命名视图实现经典布局</h2><ol><li><p>标签代码结构：</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;router-view&gt;&lt;/router-view&gt;         &lt;div class=&quot;content&quot;&gt;           &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;           &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;         &lt;/div&gt;       &lt;/div&gt;</code></pre></li><li><p>JS代码：</p><pre><code>     &lt;script&gt;         var header = Vue.component(&#39;header&#39;, {           template: &#39;&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;&#39;         });         var sidebar = Vue.component(&#39;sidebar&#39;, {           template: &#39;&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;&#39;         });         var mainbox = Vue.component(&#39;mainbox&#39;, {           template: &#39;&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;&#39;         });         // 创建路由对象         var router = new VueRouter({           routes: [             {               path: &#39;/&#39;, components: {                 default: header,                 a: sidebar,                 b: mainbox               }             }           ]         });         // 创建 Vue 实例，得到 ViewModel         var vm = new Vue({           el: &#39;#app&#39;,           data: {},           methods: {},           router         });       &lt;/script&gt;</code></pre></li><li><p>CSS 样式：</p><pre><code>&lt;style&gt; .header {   border: 1px solid red; } .content{   display: flex; } .sidebar {   flex: 2;   border: 1px solid green;   height: 500px; } .mainbox{   flex: 8;   border: 1px solid blue;   height: 500px; }&lt;/style&gt;</code></pre></li></ol><h2 id="watch属性的使用"><a href="#watch属性的使用" class="headerlink" title="watch属性的使用"></a><code>watch</code>属性的使用</h2><p>考虑一个问题：想要实现 <code>名</code> 和 <code>姓</code> 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）</p><ol><li><p>监听<code>data</code>中属性的改变：</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; +         &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; =         &lt;span&gt;{{fullName}}&lt;/span&gt;       &lt;/div&gt;       &lt;script&gt;         // 创建 Vue 实例，得到 ViewModel         var vm = new Vue({           el: &#39;#app&#39;,           data: {             firstName: &#39;jack&#39;,             lastName: &#39;chen&#39;,             fullName: &#39;jack - chen&#39;           },           methods: {},           watch: {             &#39;firstName&#39;: function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据               this.fullName = newVal + &#39; - &#39; + this.lastName;             },             &#39;lastName&#39;: function (newVal, oldVal) {               this.fullName = this.firstName + &#39; - &#39; + newVal;             }           }         });       &lt;/script&gt;</code></pre></li><li><p>监听路由对象的改变：</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;         &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;         &lt;router-view&gt;&lt;/router-view&gt;       &lt;/div&gt;       &lt;script&gt;         var login = Vue.extend({           template: &#39;&lt;h1&gt;登录组件&lt;/h1&gt;&#39;         });         var register = Vue.extend({           template: &#39;&lt;h1&gt;注册组件&lt;/h1&gt;&#39;         });         var router = new VueRouter({           routes: [             { path: &quot;/login&quot;, component: login },             { path: &quot;/register&quot;, component: register }           ]         });         // 创建 Vue 实例，得到 ViewModel         var vm = new Vue({           el: &#39;#app&#39;,           data: {},           methods: {},           router: router,           watch: {             &#39;$route&#39;: function (newVal, oldVal) {               if (newVal.path === &#39;/login&#39;) {                 console.log(&#39;这是登录组件&#39;);               }             }           }         });       &lt;/script&gt;</code></pre></li></ol><h2 id="computed计算属性的使用"><a href="#computed计算属性的使用" class="headerlink" title="computed计算属性的使用"></a><code>computed</code>计算属性的使用</h2><ol><li><p>默认只有<code>getter</code>的计算属性：</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; +         &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; =         &lt;span&gt;{{fullName}}&lt;/span&gt;       &lt;/div&gt;       &lt;script&gt;         // 创建 Vue 实例，得到 ViewModel         var vm = new Vue({           el: &#39;#app&#39;,           data: {             firstName: &#39;jack&#39;,             lastName: &#39;chen&#39;           },           methods: {},           computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值             fullName() {               return this.firstName + &#39; - &#39; + this.lastName;             }           }         });       &lt;/script&gt;</code></pre></li><li><p>定义有<code>getter</code>和<code>setter</code>的计算属性：</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;         &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;         &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt;         &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt;         &lt;span&gt;{{fullName}}&lt;/span&gt;       &lt;/div&gt;       &lt;script&gt;         // 创建 Vue 实例，得到 ViewModel         var vm = new Vue({           el: &#39;#app&#39;,           data: {             firstName: &#39;jack&#39;,             lastName: &#39;chen&#39;           },           methods: {             changeName() {               this.fullName = &#39;TOM - chen2&#39;;             }           },           computed: {             fullName: {               get: function () {                 return this.firstName + &#39; - &#39; + this.lastName;               },               set: function (newVal) {                 var parts = newVal.split(&#39; - &#39;);                 this.firstName = parts[0];                 this.lastName = parts[1];               }             }           }         });       &lt;/script&gt;</code></pre></li></ol><h2 id="watch、computed和methods之间的对比"><a href="#watch、computed和methods之间的对比" class="headerlink" title="watch、computed和methods之间的对比"></a><code>watch</code>、<code>computed</code>和<code>methods</code>之间的对比</h2><ol><li><code>computed</code>属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li><li><code>methods</code>方法表示一个具体的操作，主要书写业务逻辑；</li><li><code>watch</code>一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是<code>computed</code>和<code>methods</code>的结合体；</li></ol><h2 id="nrm的安装使用"><a href="#nrm的安装使用" class="headerlink" title="nrm的安装使用"></a><code>nrm</code>的安装使用</h2><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；<br>什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；</p><ol><li>运行<code>npm i nrm -g</code>全局安装<code>nrm</code>包；</li><li>使用<code>nrm ls</code>查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</li><li>使用<code>nrm use npm</code>或<code>nrm use taobao</code>切换不同的镜像源地址；</li></ol><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ol><li><a href="http://www.cnblogs.com/joyho/articles/4430148.html" target="_blank" rel="noopener">URL中的hash（井号）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-8-vue_resource实现向后台提交请求</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-8-vue_resource%E5%AE%9E%E7%8E%B0%E5%90%91%E5%90%8E%E5%8F%B0%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-8-vue_resource%E5%AE%9E%E7%8E%B0%E5%90%91%E5%90%8E%E5%8F%B0%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="向后台提交请求"><a href="#向后台提交请求" class="headerlink" title="向后台提交请求"></a>向后台提交请求</h1><h2 id="1-vue-resource"><a href="#1-vue-resource" class="headerlink" title="1 vue-resource"></a>1 vue-resource</h2><p><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">vue-resource</a></p><ol start="3"><li><p>测试的URL请求资源地址：</p><ul><li>get请求地址： <a href="http://vue.studyit.io/api/getlunbo" target="_blank" rel="noopener">http://vue.studyit.io/api/getlunbo</a></li><li>post请求地址：<a href="http://vue.studyit.io/api/post" target="_blank" rel="noopener">http://vue.studyit.io/api/post</a></li><li>jsonp请求地址：<a href="http://vue.studyit.io/api/jsonp" target="_blank" rel="noopener">http://vue.studyit.io/api/jsonp</a></li></ul></li><li><p>JSONP的实现原理</p><ul><li>由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；</li><li>可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；</li><li>具体实现过程：<ul><li>先在客户端定义一个回调方法，预定义对数据的操作；</li><li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；</li><li>服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；</li><li>客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；</li></ul></li><li>通过 Node.js ，来手动实现一个JSONP的请求例子；</li></ul><pre><code class="js">     const http = require(&#39;http&#39;);     // 导入解析 URL 地址的核心模块     const urlModule = require(&#39;url&#39;);     const server = http.createServer();     // 监听 服务器的 request 请求事件，处理每个请求     server.on(&#39;request&#39;, (req, res) =&gt; {       const url = req.url;       // 解析客户端请求的URL地址       var info = urlModule.parse(url, true);       // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据       if (info.pathname === &#39;/getjsonp&#39;) {         // 获取客户端指定的回调函数的名称         var cbName = info.query.callback;         // 手动拼接要返回给客户端的数据对象         var data = {           name: &#39;zs&#39;,           age: 22,           gender: &#39;男&#39;,           hobby: [&#39;吃饭&#39;, &#39;睡觉&#39;, &#39;运动&#39;]         }         // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：         var result = `${cbName}(${JSON.stringify(data)})`;         // 将拼接好的方法的调用，返回给客户端去解析执行         res.end(result);       } else {         res.end(&#39;404&#39;);       }     });     server.listen(3000, () =&gt; {       console.log(&#39;server running at http://127.0.0.1:3000&#39;);     });</code></pre></li><li><p>vue-resource 的配置步骤：</p><ul><li>直接在页面中，通过<code>script</code>标签，引入 <code>vue-resource</code> 的脚本文件；</li><li>注意：引用的先后顺序是：先引用 <code>Vue</code> 的脚本文件，再引用 <code>vue-resource</code> 的脚本文件；</li></ul></li></ol><ol start="6"><li><p>发送get请求：</p><pre><code>     getInfo() { // get 方式获取数据       this.$http.get(&#39;http://127.0.0.1:8899/api/getlunbo&#39;).then(res =&gt; {         console.log(res.body);       })     }</code></pre></li><li><p>发送post请求：</p><pre><code>     postInfo() {       var url = &#39;http://127.0.0.1:8899/api/post&#39;;       // post 方法接收三个参数：       // 参数1： 要请求的URL地址       // 参数2： 要发送的数据对象       // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded       this.$http.post(url, { name: &#39;zs&#39; }, { emulateJSON: true }).then(res =&gt; {         console.log(res.body);       });     }</code></pre></li><li><p>发送JSONP请求获取数据：</p><pre><code>     jsonpInfo() { // JSONP形式从服务器获取数据       var url = &#39;http://127.0.0.1:8899/api/jsonp&#39;;       this.$http.jsonp(url).then(res =&gt; {         console.log(res.body);       });     }</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-9-vue组件</title>
      <link href="/2020/03/06/vue%E5%9F%BA%E7%A1%80-9-vue%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/03/06/vue%E5%9F%BA%E7%A1%80-9-vue%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><h2 id="1-定义Vue组件"><a href="#1-定义Vue组件" class="headerlink" title="1 定义Vue组件"></a>1 定义Vue组件</h2><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul><li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li><li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；<h3 id="1-1-全局组件定义的三种方式"><a href="#1-1-全局组件定义的三种方式" class="headerlink" title="1.1 全局组件定义的三种方式"></a>1.1 全局组件定义的三种方式</h3></li></ul><ol><li><p>使用 Vue.extend 配合 Vue.component 方法：</p><pre><code class="html">         var login = Vue.extend({           template: &#39;&lt;h1&gt;登录&lt;/h1&gt;&#39;         });         Vue.component(&#39;login&#39;, login);</code></pre></li><li><p>直接使用 Vue.component 方法：</p><pre><code class="html">         Vue.component(&#39;register&#39;, {             template: &#39;&lt;h1&gt;注册&lt;/h1&gt;&#39;         });</code></pre></li><li><p>将模板字符串，定义到script标签种：</p><pre><code class="html">         &lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;           &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;         &lt;/script&gt;</code></pre><p>同时，需要使用 Vue.component 来定义组件：</p><pre><code class="js">         Vue.component(&#39;account&#39;, {             template: &#39;#tmpl&#39;         });</code></pre></li></ol><blockquote><p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p></blockquote><h3 id="1-2-组件中展示数据和响应事件"><a href="#1-2-组件中展示数据和响应事件" class="headerlink" title="1.2 组件中展示数据和响应事件"></a>1.2 组件中展示数据和响应事件</h3><ol><li><p>在组件中，<code>data</code>需要被定义为一个方法，例如：</p><pre><code class="js">     Vue.component(&#39;account&#39;, {           template: &#39;#tmpl&#39;,           data() {             return {               msg: &#39;大家好！&#39;             }           },           methods:{             login(){               alert(&#39;点击了登录按钮&#39;);             }           }      });</code></pre></li><li><p>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</p></li></ol><h2 id="2-组件中data属性-重点"><a href="#2-组件中data属性-重点" class="headerlink" title="2 组件中data属性(重点)"></a>2 组件中data属性(重点)</h2><p><strong>【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象</strong></p><h2 id="3-父组件向子组件传值"><a href="#3-父组件向子组件传值" class="headerlink" title="3 父组件向子组件传值"></a>3 父组件向子组件传值</h2><ol><li><p>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</p><pre><code>     &lt;script&gt;         // 创建 Vue 实例，得到 ViewModel         var vm = new Vue({           el: &#39;#app&#39;,           data: {             msg: &#39;这是父组件中的消息&#39;           },           components: {             son: {               template: &#39;&lt;h1&gt;这是子组件 --- {{finfo}}&lt;/h1&gt;&#39;,               props: [&#39;finfo&#39;]             }           }         });       &lt;/script&gt;</code></pre></li><li><p>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt;     &lt;/div&gt;</code></pre></li></ol><h2 id="4-子组件向父组件传值"><a href="#4-子组件向父组件传值" class="headerlink" title="4 子组件向父组件传值"></a>4 子组件向父组件传值</h2><ol><li><p>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</p></li><li><p>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</p><pre><code>     &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</code></pre></li><li><p>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</p><pre><code>     &lt;div id=&quot;app&quot;&gt;         &lt;!-- 引用父组件 --&gt;         &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;         &lt;!-- 组件模板定义 --&gt;         &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt;           &lt;div&gt;             &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt;           &lt;/div&gt;         &lt;/script&gt;       &lt;/div&gt;       &lt;script&gt;         // 子组件的定义方式         Vue.component(&#39;son&#39;, {           template: &#39;#son&#39;, // 组件模板Id           methods: {             sendMsg() { // 按钮的点击事件               this.$emit(&#39;func&#39;, &#39;OK&#39;); // 调用父组件传递过来的方法，同时把数据传递出去             }           }         });         // 创建 Vue 实例，得到 ViewModel         var vm = new Vue({           el: &#39;#app&#39;,           data: {},           methods: {             getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义               alert(val);             }           }         });       &lt;/script&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo安装</title>
      <link href="/2020/03/06/hexo%E5%AE%89%E8%A3%85/"/>
      <url>/2020/03/06/hexo%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官网: https://hexo.io/zh-cn/</a></p><pre><code>    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。    Hexo可以一键部署到github上</code></pre><h2 id="1-安装hexo-github-hexo"><a href="#1-安装hexo-github-hexo" class="headerlink" title="1 安装hexo(github+hexo)"></a>1 安装hexo(github+hexo)</h2><h3 id="1-1-安装前提"><a href="#1-1-安装前提" class="headerlink" title="1.1 安装前提"></a>1.1 安装前提</h3><pre><code>需要安装软件    nodejs 版本不低于8.10,建议用10.0版本以上    git    </code></pre><h3 id="1-2-安装步骤"><a href="#1-2-安装步骤" class="headerlink" title="1.2 安装步骤"></a>1.2 安装步骤</h3><pre><code class="bash">// 全局安装hexonpm install hexo-cli -g// 创建&quot;blog&quot;博客项目hexo init blog// 进入博客项目cd blog// 安装依赖npm install// 安装git部署插件npm install --save hexo-deployer-git// 安装图片上传插件npm install hexo-asset-image --save// 运行系统hexo server</code></pre><h3 id="1-3-github创建仓库"><a href="#1-3-github创建仓库" class="headerlink" title="1.3 github创建仓库"></a>1.3 github创建仓库</h3><pre><code>在github上创建仓库 仓库名固定为: xxx.github.io  (xxx为github的用户名)                        示例: 1352148827.github.io</code></pre><h3 id="1-4-配置-config-yml"><a href="#1-4-配置-config-yml" class="headerlink" title="1.4 配置_config.yml"></a>1.4 配置_config.yml</h3><p>在_config.yml中配置git的地址</p><pre><code class="yaml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/1352148827/1352148827.github.io.git  branch: master</code></pre><h3 id="1-5-部署到github上"><a href="#1-5-部署到github上" class="headerlink" title="1.5 部署到github上"></a>1.5 部署到github上</h3><pre><code>在博客项目下执行命令:    hexo deploy</code></pre><h3 id="1-4-hexo目录结构"><a href="#1-4-hexo目录结构" class="headerlink" title="1.4 hexo目录结构"></a>1.4 hexo目录结构</h3><pre><code>hexo目录结构主义分为三个部分,一个配置文件, _config.yml是网站的配置,scaffolds目录是存放模板的,source目录主要存放资源文件的,themes目录主要是存放主题的</code></pre><pre><code>.├── _config.yml        // 网站配置信息;参考:├── package.json├── scaffolds        // 模板文件夹    参考: https://hexo.io/zh-cn/docs/writing├── source            // 资源文件夹是存放用户资源的地方除|   ├── _drafts|   └── _posts└── themes            // 主题文件夹,Hexo 会根据主题来生成静态页面。                     // 参考:https://hexo.io/zh-cn/docs/themes</code></pre><pre><code>source目录:  _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</code></pre><h2 id="2-hexo使用"><a href="#2-hexo使用" class="headerlink" title="2 hexo使用"></a>2 hexo使用</h2><h3 id="2-0-hexo上传github命令"><a href="#2-0-hexo上传github命令" class="headerlink" title="2.0 hexo上传github命令"></a>2.0 hexo上传github命令</h3><pre><code>hexo cleanhexo ghexo d</code></pre><h3 id="2-1-hexo创建文章"><a href="#2-1-hexo创建文章" class="headerlink" title="2.1 hexo创建文章"></a>2.1 hexo创建文章</h3><pre><code>hexo new 模板名 &quot;文章名称&quot;hexo new post  &quot;My New Post&quot;</code></pre><h3 id="2-2-启动项目"><a href="#2-2-启动项目" class="headerlink" title="2.2 启动项目"></a>2.2 启动项目</h3><pre><code>hexo servernpm run server</code></pre><h3 id="2-3-编译项目"><a href="#2-3-编译项目" class="headerlink" title="2.3 编译项目"></a>2.3 编译项目</h3><pre><code>hexo generatenpm run build</code></pre><h3 id="2-4-清理项目"><a href="#2-4-清理项目" class="headerlink" title="2.4 清理项目"></a>2.4 清理项目</h3><pre><code>hexo cleannpm run clean</code></pre><h3 id="2-5-部署github"><a href="#2-5-部署github" class="headerlink" title="2.5 部署github"></a>2.5 部署github</h3><pre><code>hexo deploynpm run deploy</code></pre><h3 id="2-6-查看博客"><a href="#2-6-查看博客" class="headerlink" title="2.6 查看博客"></a>2.6 查看博客</h3><pre><code>https://github用户名.github.io示例 https://1352148827.github.io</code></pre><h2 id="3-hexo的背景"><a href="#3-hexo的背景" class="headerlink" title="3 hexo的背景"></a>3 hexo的背景</h2><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">更多背景参考: https://hexo.io/themes/ </a></p><h3 id="3-1-yilia"><a href="#3-1-yilia" class="headerlink" title="3.1 yilia"></a>3.1 yilia</h3><pre><code>git clone https://github.com/litten/hexo-theme-yilia themes/yilia</code></pre><h3 id="3-2-3-hexo"><a href="#3-2-3-hexo" class="headerlink" title="3.2 3-hexo"></a>3.2 3-hexo</h3><pre><code>git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用</title>
      <link href="/2020/03/06/hexo%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/06/hexo%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-hexo部署"><a href="#1-hexo部署" class="headerlink" title="1 hexo部署"></a>1 hexo部署</h2><pre><code class="bash">hexo cleanhexo ghexo d</code></pre><h2 id="2-hexo快捷键"><a href="#2-hexo快捷键" class="headerlink" title="2 hexo快捷键"></a>2 hexo快捷键</h2><p><img src="/2020/03/06/hexo%E4%BD%BF%E7%94%A8/1.jpg" alt></p><h2 id="3-模板"><a href="#3-模板" class="headerlink" title="3 模板"></a>3 模板</h2><pre><code class="bash">title: hexo使用date: 2020-03-06 10:32:12categories:tags:</code></pre><h2 id="4-本地启动"><a href="#4-本地启动" class="headerlink" title="4 本地启动"></a>4 本地启动</h2><pre><code class="bash">hexo server</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
